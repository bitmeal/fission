#!/bin/sh
#!/usr/bin/dumb-init /bin/sh

### config
#FISSION_VERBOSE="false"
__FISSION_FILE="/etc/fission/fission.json"
__FISSION_OVERLAY_DIR="/etc/fission/overlays"
__FISSION_RUNSVDIR="/etc/service"
__FISSION_LOGDIR="/var/log"
__FISSION_RUNSVDIR_CMD="runsvdir -P ${__FISSION_RUNSVDIR}"
__FISSION_SILENT="false"
__FISSION_SILENT_REDIRECT=""
__FISSION_STDERR="true"
__FISSION_STDERR_TARGET="/proc/1/fd/2"
# __FISSION_STDERR_TARGET="/dev/stderr"

### helpers/methods
log()
{
    if ! ${__FISSION_SILENT}; then
        echo $@
    fi
}

log_verbose()
{
    if ${FISSION_VERBOSE}; then
        echo $@
    fi
}

# print commandline with apropriate stderr redirection for logging
# > redirect output or use with substitution!
cmdl_redirect_print()
{
    if ${__FISSION_STDERR}; then
        # forward stderr to terminal and log
        echo "{ { $@; } 2>&1 1>&127 | tee ${__FISSION_STDERR_TARGET}; } 127>&1"
    else
        # hide stderr from terminal
        echo "{ $@; } 2>&1"
    fi
}

### check usage
# check arguments
__FISSION_USAGE="usage: fission command [options] [-- command2 [options]]"
if [ ${#} -eq 0 ]; then
    echo ${__FISSION_USAGE}
    exit 1
fi
if [ "${1}" = "--" ]; then
    echo ${__FISSION_USAGE}
    exit 1
fi

# check fission.json exists
if [ ! -f "${__FISSION_FILE}" ] ; then
    echo "configuration file ${__FISSION_FILE} missing"
    exit 1
fi

# test fission.json and overlays
LC_COLLATE=C
__FISSION_OVERLAYS="$(if [ -d ${__FISSION_OVERLAY_DIR} ]; then echo ${__FISSION_OVERLAY_DIR}/*; fi)"
for __FISSION_CONFIG_FILE in ${__FISSION_FILE} ${__FISSION_OVERLAYS}; do
    if ! jq '.' "${__FISSION_CONFIG_FILE}" > /dev/null; then
        echo "cannot parse ${__FISSION_CONFIG_FILE}; review jq error output above"
        exit 1
    fi
    if [ "$(jq -r 'type' ${__FISSION_CONFIG_FILE})" != "object" ]; then
        echo "configuration file ${__FISSION_CONFIG_FILE} is not an object"
        exit 1
    fi
done

# build config from overlays
# jq -rs 'reduce .[] as $item ({}; . * $item) | with_entries(.value = (.value | with_entries(select( .value != null ))))' ${__FISSION_FILE} ${__FISSION_OVERLAYS}
# pre jq 1.6 compatible
__FISSION_CONFIG=$(jq -rs 'reduce .[] as $item ({}; . * $item) | walk( if type == "object" then with_entries(select(.value != null)) else . end)' ${__FISSION_FILE} ${__FISSION_OVERLAYS})

### fetch fission config options
# verbosity
if [ "${FISSION_VERBOSE}" = "" ]; then
    FISSION_VERBOSE="false"
fi
# silent
__FISSION_SILENT=$(echo "${__FISSION_CONFIG}" | jq '.silent // false')
    # disable silence when verbose
    if ${FISSION_VERBOSE}; then
        __FISSION_SILENT="false"
    fi
    # redirect all command output on silence
    if ${__FISSION_SILENT}; then
        __FISSION_SILENT_REDIRECT=">/dev/null"
    fi

    log_verbose "# silent: ${__FISSION_SILENT}"

# stderr forwarding
__FISSION_STDERR=$(echo "${__FISSION_CONFIG}" | jq -e 'if has("stderr") then .stderr else true end')
    log_verbose "# stderr: ${__FISSION_STDERR}"


### detect init system
# TODO: detect init system

### replace PID1
if [ $$ -eq 1 ]; then
	log "> spawning dumb-init as PID1..."
	exec dumb-init "${0}" "${@}"
fi

### load env
# TODO: use jq @sh quoting
log "> loading env..."
for __FISSION_ENV_VAR in $(echo "${__FISSION_CONFIG}" | jq -r '.env // empty | keys | .[]'); do
    __FISSION_ENV_VAR_VAL=$(echo "${__FISSION_CONFIG}" | jq -r ".env.\"${__FISSION_ENV_VAR}\"")
    log "- ${__FISSION_ENV_VAR}"
    log_verbose '`-: '"${__FISSION_ENV_VAR_VAL}"
    export ${__FISSION_ENV_VAR}="${__FISSION_ENV_VAR_VAL}"
    unset __FISSION_ENV_VAR_VAL
done

### source init scripts
log "> running init tasks..."
for __FISSION_INIT in $(echo "${__FISSION_CONFIG}" | jq -rS '.init // empty | keys | .[]'); do
    __FISSION_INIT_TARGET=$(echo "${__FISSION_CONFIG}" | jq -r ".init.\"${__FISSION_INIT}\"")

    log_verbose "${__FISSION_INIT}"
    log_verbose "${__FISSION_INIT_TARGET}"

    if [ -e ${__FISSION_INIT_TARGET} -o "${__FISSION_INIT_TARGET}" = "" ]; then
        if [ -d ${__FISSION_INIT_TARGET} ]; then
            # is directory
            log "+ ${__FISSION_INIT_TARGET}"
            for __FISSION_INIT_TARGET_SCRIPT in $(find -L ${__FISSION_INIT_TARGET} -type f -executable -name '*' | sort -f); do
                if [ -e "${__FISSION_INIT_TARGET_SCRIPT}" ] ; then
                    log "|- ${__FISSION_INIT_TARGET_SCRIPT}"
                    . "${__FISSION_INIT_TARGET_SCRIPT}" ${__FISSION_SILENT_REDIRECT}
                fi
            done
        else
            # is file
            log "- ${__FISSION_INIT_TARGET}"
            . "${__FISSION_INIT_TARGET}" ${__FISSION_SILENT_REDIRECT}
        fi
    else
        log "- [ERR] ${__FISSION_INIT_TARGET} does not exist!"
    fi

    unset __FISSION_INIT_TARGET
done


### create services & logging
# TODO: call services with init binary for signal forwarding and child reaping
# logging with stdout and stderr to file + stderr to screen
log "> creating services..."
for __FISSION_SERVICE in $(echo "${__FISSION_CONFIG}" | jq -r '.services // empty | keys | .[]'); do
    # log "creating service: ${__FISSION_SERVICE}"
    log "- ${__FISSION_SERVICE}"
    # get service command line without trailing semicollon (";")
    __FISSION_SERVICE_CMDL=$(echo "${__FISSION_CONFIG}" | jq -r ".services.\"${__FISSION_SERVICE}\"")
    __FISSION_SERVICE_CMDL="$(echo ${__FISSION_SERVICE_CMDL} | sed 's/;[[:space:]]*$//')"
    log_verbose '`-: '"${__FISSION_SERVICE_CMDL}"

    mkdir -p "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log"

    # (re)create service file
    echo "#!/bin/sh" > "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/run"
    # write service file with requested stderr logging mode
    cmdl_redirect_print ${__FISSION_SERVICE_CMDL} >> "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/run"
    chmod +x "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/run"

    # (re)create logger
    echo "#!/bin/sh" > "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log/run"
    echo "exec svlogd -tt ${__FISSION_LOGDIR}/${__FISSION_SERVICE}" >> "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log/run"
    chmod +x "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log/run"
    mkdir -p "${__FISSION_LOGDIR}/${__FISSION_SERVICE}"

    unset __FISSION_SERVICE_CMDL
done



### run services
log "> starting services..."
( setsid ${__FISSION_RUNSVDIR_CMD} ${__FISSION_SILENT_REDIRECT} & )

### exec
# build primary command till '--' or end of options
while [ ${#} -ne 0 ] && [ "${1}" != "--" ]; do
    __FISSION_PRIMARY="${__FISSION_PRIMARY} ${1}"
    shift
done
log_verbose "# main cmdl: ${__FISSION_PRIMARY}"

# has an auxilliary command after -- ?
if [ "${1}" = "--" ] && [ ${#} -gt 1 ]; then
    # create logging directory
    mkdir -p "${__FISSION_LOGDIR}/app"
	# run primary command in background
    log "> running main process in background [logging to ${__FISSION_LOGDIR}/app]..."
    ( setsid sh -c "$(cmdl_redirect_print ${__FISSION_PRIMARY})" | svlogd -tt ${__FISSION_LOGDIR}/app & )

    shift
else
	# run primary command in foreground and replace process
    log "> starting main process..."
    exec sh -c "${__FISSION_PRIMARY}"
fi

# -> process replaced here if no auxilliary command is given
# --


# run auxilliary command and replace process
while [ ${#} -ne 0 ]; do
    __FISSION_AUXILLIARY="${__FISSION_AUXILLIARY} ${1}"
    shift
done
log_verbose "# aux cmdl: ${__FISSION_AUXILLIARY}"
log "> starting aux process..."

exec sh -c "${__FISSION_AUXILLIARY}"