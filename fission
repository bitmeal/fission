#!/usr/bin/env sh

### config
FISSION_BINARY=$(readlink -f "${0}")
FISSION_PATH=$(dirname "${FISSION_BINARY}")
FISSION_CALL=$(basename "${0}")

#FISSION_VERBOSE="false"
#FISSION_SHELL=""
__FISSION_SILENT="false"
__FISSION_FILE="/etc/fission/fission.json"
__FISSION_OVERLAY_DIR="/etc/fission/overlays"
__FISSION_RUNSVDIR="/etc/service"
__FISSION_LOGDIR="/var/log"
__FISSION_RUNSVDIR_CMD="runsvdir -P ${__FISSION_RUNSVDIR}"
__FISSION_SILENT_REDIRECT=""
__FISSION_STDERR="true"
__FISSION_STDERR_TARGET="/proc/1/fd/2"


### MULTICALL SCRIPT
# -> see end of file
__FISSION_MULTICALL_ALIASES="fission-spawn fission-run fission-runsv fission-auxmain fission-getconf"


### helpers/methods
log_multicall()
{
    log_verbose "called as ${FISSION_CALL}"
}

log()
{
    if ! ${__FISSION_SILENT}; then
        printf "$@\n" | sed 's/^/> /g'
    fi
}

log_verbose()
{
    if ${FISSION_VERBOSE}; then
        printf "$@\n" | sed 's/^/# /g'
    fi
}

common_config()
{
    # verbosity
    if [ "${FISSION_VERBOSE}" = "" ]; then
        FISSION_VERBOSE="false"
    fi

    # silent
    __FISSION_SILENT=$(echo "${FISSION_CONFIG}" | jq '.silent // false')
        # disable silence when verbose
        if ${FISSION_VERBOSE}; then
            __FISSION_SILENT="false"
        fi
        # redirect all command output on silence
        if ${__FISSION_SILENT}; then
            __FISSION_SILENT_REDIRECT=">/dev/null"
        fi


    # stderr forwarding
    __FISSION_STDERR=$(echo "${FISSION_CONFIG}" | jq -e 'if has("stderr") then .stderr else true end')

    log_multicall
}


### MULTICALL FUNCTIONS

## get config as json string
get_conf()
{
    LC_COLLATE=C
    __FISSION_OVERLAYS="$(if [ -d ${__FISSION_OVERLAY_DIR} ]; then echo ${__FISSION_OVERLAY_DIR}/*; fi)"

    ### fetch fission config
    # build config from overlays
    # jq -rs 'reduce .[] as $item ({}; . * $item) | with_entries(.value = (.value | with_entries(select( .value != null ))))' ${__FISSION_FILE} ${__FISSION_OVERLAYS}
    # pre jq 1.6 compatible
    jq -rs 'reduce .[] as $item ({}; . * $item) | walk( if type == "object" then with_entries(select(.value != null)) else . end)' ${__FISSION_FILE} ${__FISSION_OVERLAYS}
}

## INIT STEP 1
# check usage
# build/get config
# replace pid1
setup_init() #${@}
{
    # check arguments
    __FISSION_USAGE="usage: fission command [options] [-- command2 [options]]"
    if [ ${#} -eq 0 ]; then
        printf "${__FISSION_USAGE}\n"
        exit 1
    fi
    if [ "${1}" = "--" ]; then
        printf "${__FISSION_USAGE}\n"
        exit 1
    fi

    # link multicall aliases
    for __FISSION_ALIAS in ${__FISSION_MULTICALL_ALIASES}; do
        ln -s ${FISSION_BINARY} ${FISSION_PATH}/${__FISSION_ALIAS}
    done

    # update path to use local binaries
    export PATH=${FISSION_PATH}:${PATH}

    # check fission.json exists
    if [ ! -f "${__FISSION_FILE}" ] ; then
        printf "configuration file ${__FISSION_FILE} missing\n"
        exit 1
    fi

    # test fission.json and overlays
    LC_COLLATE=C
    __FISSION_OVERLAYS="$(if [ -d ${__FISSION_OVERLAY_DIR} ]; then echo ${__FISSION_OVERLAY_DIR}/*; fi)"
    for __FISSION_CONFIG_FILE in ${__FISSION_FILE} ${__FISSION_OVERLAYS}; do
        if ! jq '.' "${__FISSION_CONFIG_FILE}" > /dev/null; then
            printf "cannot parse ${__FISSION_CONFIG_FILE}; review jq error output above\n"
            exit 1
        fi
        if [ "$(jq -r 'type' ${__FISSION_CONFIG_FILE})" != "object" ]; then
            printf "configuration file ${__FISSION_CONFIG_FILE} is not an object\n"
            exit 1
        fi
    done


    ### fetch fission config
    export FISSION_CONFIG="$(${FISSION_SHELL} ${FISSION_PATH}/fission-getconf)"

    # setup common configuration variables
    common_config

    ## logging
    # postponed logging after config has been read to respect silence flag
    log_verbose "silent: ${__FISSION_SILENT}"
    log_verbose "stderr: ${__FISSION_STDERR}"
    log_verbose "using config:"
    log_verbose "$(echo ${FISSION_CONFIG} | jq -C .)"
    log_verbose "created multicall aliases: ${__FISSION_MULTICALL_ALIASES}"
    log "updating PATH as ${FISSION_PATH}:"'${PATH}'


    ### replace PID1
    if [ $$ -eq 1 ]; then
        log "spawning fpco/pid1 as PID1..."
        exec pid1 ${FISSION_PATH}/fission-spawn ${@}
    fi
    # TODO: allow fpco/pid1 SIGKILL timeout configuration
}


## INIT STEP 2
# respawn with shell from /etc/passwd
select_shell()
{
    # setup common configuration variables
    common_config

    # respawn with shell from /etc/passwd
    if [ -z ${FISSION_SHELL} ]; then
        export FISSION_SHELL=$(getent passwd $(whoami) | cut -d ':' -f 7)
        log "replacing /bin/sh as executor with ${FISSION_SHELL}..."
        exec ${FISSION_SHELL} ${FISSION_PATH}/fission-run ${@}
    fi
}


## INIT STEP 3
# setup environment
# run init scripts
# start services
# run main & aux process(es)
run()
{
    # setup common configuration variables
    common_config

    ### load env
    # TODO: use jq @sh quoting?
    log "loading env..."
    for __FISSION_ENV_VAR in $(echo "${FISSION_CONFIG}" | jq -r '.env // empty | keys | .[]'); do
        __FISSION_ENV_VAR_VAL=$(echo "${FISSION_CONFIG}" | jq -r ".env.\"${__FISSION_ENV_VAR}\"")
        log "- ${__FISSION_ENV_VAR}"
        log_verbose '`-: '"${__FISSION_ENV_VAR_VAL}"
        export ${__FISSION_ENV_VAR}="${__FISSION_ENV_VAR_VAL}"
        unset __FISSION_ENV_VAR_VAL
    done

    ### source init scripts
    log "running init tasks..."
    for __FISSION_INIT in $(echo "${FISSION_CONFIG}" | jq -rS '.init // empty | keys | .[]'); do
        __FISSION_INIT_TARGET=$(echo "${FISSION_CONFIG}" | jq -r ".init.\"${__FISSION_INIT}\"")

        log_verbose "${__FISSION_INIT}"
        log_verbose "${__FISSION_INIT_TARGET}"

        if [ -e ${__FISSION_INIT_TARGET} -o "${__FISSION_INIT_TARGET}" = "" ]; then
            if [ -d ${__FISSION_INIT_TARGET} ]; then
                # is directory
                log "+ ${__FISSION_INIT_TARGET}"
                for __FISSION_INIT_TARGET_SCRIPT in $(find -L ${__FISSION_INIT_TARGET} -type f -executable -name '*' | sort -f); do
                    if [ -e "${__FISSION_INIT_TARGET_SCRIPT}" ] ; then
                        log "|- ${__FISSION_INIT_TARGET_SCRIPT}"
                        . "${__FISSION_INIT_TARGET_SCRIPT}" ${__FISSION_SILENT_REDIRECT}
                    fi
                done
            else
                # is file
                log "- ${__FISSION_INIT_TARGET}"
                . "${__FISSION_INIT_TARGET}" ${__FISSION_SILENT_REDIRECT}
            fi
        else
            log "- [ERR] ${__FISSION_INIT_TARGET} does not exist!"
        fi

        unset __FISSION_INIT_TARGET
    done


    ### create services & logging
    # logging with stdout and stderr to file + stderr to screen
    log "creating services..."
    mkdir -p ${__FISSION_RUNSVDIR}
    for __FISSION_SERVICE in $(echo "${FISSION_CONFIG}" | jq -r '.services // empty | keys | .[]'); do
        # log "creating service: ${__FISSION_SERVICE}"
        log "- ${__FISSION_SERVICE}"
        __FISSION_SERVICE_CMDL=$(echo "${FISSION_CONFIG}" | jq -r ".services.\"${__FISSION_SERVICE}\"")
        log_verbose '`-: '"${__FISSION_SERVICE_CMDL}"

        mkdir -p "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log"

        # (re)create service file
        echo "#!${FISSION_SHELL}" > "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/run"
        # write service file with requested stderr logging mode
        echo "exec ${FISSION_SHELL} ${FISSION_PATH}/fission-runsv ${__FISSION_SERVICE_CMDL}" >> "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/run"
        chmod +x "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/run"

        # (re)create logger
        echo "#!${FISSION_SHELL}" > "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log/run"
        echo "exec svlogd -tt ${__FISSION_LOGDIR}/${__FISSION_SERVICE}" >> "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log/run"
        chmod +x "${__FISSION_RUNSVDIR}/${__FISSION_SERVICE}/log/run"
        mkdir -p "${__FISSION_LOGDIR}/${__FISSION_SERVICE}"

        unset __FISSION_SERVICE_CMDL
    done



    ### run services
    log "starting services..."
    ( setsid ${__FISSION_RUNSVDIR_CMD} ${__FISSION_SILENT_REDIRECT} & )

    ### exec
    # build primary command till '--' or end of options
    while [ ${#} -ne 0 ] && [ "${1}" != "--" ]; do
        __FISSION_PRIMARY="${__FISSION_PRIMARY} ${1}"
        shift
    done
    log_verbose "main cmdl: ${__FISSION_PRIMARY}"

    # has an auxilliary command after -- ?
    if [ "${1}" = "--" ] && [ ${#} -gt 1 ]; then
        # create logging directory
        mkdir -p "${__FISSION_LOGDIR}/app"
        # run primary command in background
        log "running main process in background [logging to ${__FISSION_LOGDIR}/app]..."
        ( setsid ${FISSION_SHELL} ${FISSION_PATH}/fission-auxmain ${__FISSION_PRIMARY} & )

        shift
    else
        # run primary command in foreground and replace process
        log "starting main process..."
        # TODO: remove shell call
        exec "${FISSION_SHELL}" -c "${__FISSION_PRIMARY}"
    fi

    # -> process replaced here if no auxilliary command is given
    # --


    # run auxilliary command and replace process
    while [ ${#} -ne 0 ]; do
        __FISSION_AUXILLIARY="${__FISSION_AUXILLIARY} ${1}"
        shift
    done
    log_verbose "aux cmdl: ${__FISSION_AUXILLIARY}"
    log "starting aux process..."

    exec "${FISSION_SHELL}" -c "${__FISSION_AUXILLIARY}"
}


### log/stderr redirection
# will both run command:
#   - in new backgrounded shell
#   - shell as new process group leader
# -> allows signal forwarding as this process and handlers/traps stay active
# -> allows to forwarding signals to all child processes (including tee) by group

## run command and handle stderr redirection
# TODO: remove additional shell call
cmd_redirect_stderr()
{
    common_config
    
    # redirect fd 127 to stdout
    exec 127>&1

    if ${__FISSION_STDERR}; then
        setsid ${FISSION_SHELL} -c "${*} 2>&1 1>&127 | setsid tee ${__FISSION_STDERR_TARGET}" &
    else
        setsid ${FISSION_SHELL} -c "${*}" 2>&1 &
    fi

    # get group id
    GROUP_LEADER_PID=$!
    PROC_GROUP_ID=$(ps -o pgid -p ${GROUP_LEADER_PID} | tail -n 1 | tr -d ' ')
    # PROC_GROUP_ID="$(ps -o pid,pgid | grep -E '^\s+${GROUP_LEADER_PID}\s+' | sed -E 's/\s*(\S+)\s*/\1\t/g' | cut -f 2 | tr -d '\t ')"

    # install trap
    #   - make SIGINT and SIGTERM send SIGTERM to child pgroup
    #   - keeps tee running; will exit on broken pipe
    trap "kill -- -${PROC_GROUP_ID}" SIGINT SIGTERM

    # wait for command to finish (keep process running and forward signals)
    wait
    exit $?
}

## run main command and handle stderr redirection in presence of auxilliary command
main_redirect_stderr()
{
    common_config

    # create FIFO to be used as "anonymous pipe"
    # attach to file descriptor
    # remove fifo link as cleanup step
    # file descriptor will stay open as long as the shell
    #------------------------------------------------------
    PIPE=$(mktemp -u fifo.XXXXXX)
    mkfifo ${PIPE}
    exec 127<>${PIPE}
    rm ${PIPE}
    #------------------------------------------------------
    
    # attach logger
    setsid svlogd -tt ${__FISSION_LOGDIR}/app <&127 &
    # LOGGER_PID=$!

    if ${__FISSION_STDERR}; then
        setsid ${FISSION_SHELL} -c "trap ' ' SIGINT SIGTERM; ${*} 2>&1 1>&127 | setsid tee ${__FISSION_STDERR_TARGET} 1>&127" &
    else
        setsid ${FISSION_SHELL} -c "trap ' ' SIGINT SIGTERM; ${*} 1>&127 2>&127" &
    fi

    # get group id
    GROUP_LEADER_PID=$!
    PROC_GROUP_ID=$(ps -o pgid -p ${GROUP_LEADER_PID} | tail -n 1 | tr -d ' ')

    # install trap
    #   - make SIGINT and SIGTERM send SIGTERM to child pgroup
    #   - keeps tee running; will exit on broken pipe
    #   - keeps svlogd running; will be terminated after succesfull wait on group leader (below)
    trap "trap ' ' SIGINT SIGTERM; kill -- -${PROC_GROUP_ID};" SIGINT SIGTERM

    # wait for command to finish
    wait ${GROUP_LEADER_PID}

    # terminate remaining background commands (svlogd)
    jobs > /dev/null; jobs -p | xargs -i kill {}
    wait
    exit $?
}

### MAIN
### multicall selector
case "${FISSION_CALL}" in
    "fission")          setup_init ${@} ;;
    "fission-spawn")    select_shell ${@} ;;
    "fission-run")      run ${@} ;;
    "fission-runsv")    cmd_redirect_stderr ${@} ;;
    "fission-auxmain")  main_redirect_stderr ${@} ;;
    "fission-getconf")  get_conf ${@} ;;
    *)                  echo "fission called as unknown command" >&2; exit 1;;
esac
